# Camunda BPM Prometheus Metrics Process Engine Plugin


Camunda Process Engine Plugin that implements a Prometheus Client HTTP Server, Collectors for the Camunda Metric 
system, Examples of Custom metric collection occuring based on a timer, and reusable collect metric classes that 
can be used throughout BPMN, CMMN and DMN executions. 


WIP

Currently functional, but still testing


![basic 1](./docs/images/basic1.png)
![testprocess](./docs/images/testProcess.png)
![config 1](./docs/images/config1.png)

# Script examples for BPMN, DMN, CMMN execution: Creating and using Metric within the BPM execution
 
 **Groovy script Examples:**

```groovy
import io.digitalstate.camunda.prometheus.collectors.SimpleGaugeMetric;

def openCases = new SimpleGaugeMetric('open_cases', 'Number of Open Cases, labeled by Case Type', ['type'])

openCases.increment(['standard'])
```

```groovy
import io.digitalstate.camunda.prometheus.collectors.SimpleHistogramMetric

def httpRequest = new SimpleHistogramMetric('legacy_system_123_request', 'Connection duration time, labeled by HTTP Method', null, ['method'])

httpRequest.startTimer(['POST'])

sleep(Math.abs(new Random().nextInt() % 5000) + 650) // Simulates a delay

httpRequest.observeDuration()

```

```groovy
import io.digitalstate.camunda.prometheus.collectors.SimpleGaugeMetric

def money = new SimpleGaugeMetric('money_collected', 'dollar values collected, labeled by form of payment', ['payment_form'])

def amount = Math.abs(new Random().nextDouble() % 284.03) + 23.54 // Random dollar value
money.increment(amount, ['credit-card'])
```

```groovy
import io.digitalstate.camunda.prometheus.collectors.SimpleGaugeMetric

def openCases = new SimpleGaugeMetric('open_cases')

openCases.decrement(['standard'])

def closedCases = new SimpleGaugeMetric('closed_cases', 'Number of Open Cases, labeled by Case Type', ['type'])
closedCases.increment(['standard'])
```

# Metrics Classes

Simple but reusable metrics are provided for ease of use by BPMN process builders.

1. SimpleGaugeMetric (io.digitalstate.camunda.prometheus.collectors.SimpleGaugeMetric)
1. SimpleCounterMetric (io.digitalstate.camunda.prometheus.collectors.SimpleCounterMetric)
1. SimpleHistogramMetric (io.digitalstate.camunda.prometheus.collectors.SimpleHistorgramMetric)
1. SimpleSummaryMetric (io.digitalstate.camunda.prometheus.collectors.SimpleSummaryMetric)

See the Test folder for further usage, and see the metric classes.  They are generally simplifications over the existing metrics API.  They are designed to remove "extras" and simplify usage.

# Namspace

the `camunda` namespace is given to all metrics generated by the Simple Metric classes.

# Prometheus Collector Registry

The Default registry is used.

# Labels

Labels are supported and are generally implemented as a optional parameter in the method.  See examples above.


# Plugin Configuration

```xml
<!-- engine plugins -->
<property name="processEnginePlugins">
    <list>
        ...
            <bean id="prometheusPlugin" class="io.digitalstate.camunda.prometheus.PrometheusProcessMetricsProcessEnginePlugin">
                 <property name="port" value="9999" />
                 <property name="pollingFrequencyMills">
                     <value type="java.lang.Long">5000</value>
                 </property>
                 <property name="pollingStartDelayMills">
                     <value type="java.lang.Long">0</value>
                 </property>
                 <property name="queryStartDate" value="2015-10-03T17:59:38+00:00"/>
            </bean>
        ...
    </list>
</property>
```

The port is the port that the HTTP Server that Prometheus will use to access the metrics.

# Default Metrics

Notes:

1. All default metrics are configured through the plugin properties of `pollingFrequencyMills` and `pollingStartDelayMills`.
1. All default metrics use a `engine_name` label which is used to identity the unique engine collecting the metrics.

There is two default metrics that are loaded:

## Camunda Engine Metrics (Default metric system/queries provided by Camunda):

All custom metrics as defined in the Camunda Metrics documentation are implemented:

LINK to Camunda Metrics Docs are located here.

Metric names follow the pattern of:

`metric_[metric name using underscores]`

Example:  Using the Camunda metric `activity-instance-start`, the metric would be created as 
`metric_activity_instance_start`, and would appear in Prometheus / Grafana as `camunda_metric_activity_instance_start`, 
where the `camunda_` is the namespace of the metric


## Camunda Custom Metrics

Custom are currently designed as example usage of metrics.  The Custom metrics implement the following collection:

1. Management Statistics Query of Process Definitions: Generates a Gauge count of Process Definition Key and total 
process instance count.


# Prometheus Setup:

You can use a docker container such as:

https://github.com/vegasbrianc/prometheus

and in the /prometheus/prometheus.yml file, add the following in the `scrape_configs` section

```yml
  - job_name: 'camunda'
    scrape_interval: 5s
    static_configs:
        - targets: ['localhost:9999']
```

where `localhost` is the domain of the Camunda server and `9999` is the port configured in the process engine plugin configuration xml.



# Todo:

1. Add try/catch to all registration and modifications and log errors rather than throwing error.
1. Add Better Prometheus usage docs
1. Add screenshots of examples of dashboards
1. :exclamation: Add Camunda Startup logic to perform Engine queries for pre-population of initial values/current values of metrics.  Example: If a count or gauge is running that is tracking a "number of dollars collected", if camunda is restarted, we want to recalculate this value on startup so we are not restarting at zero.